use std::{
    fs::OpenOptions,
    io::{BufWriter, Write},
    iter::zip,
};

use clap::Parser;
use opencv::core::{ToInputArray, ToOutputArray};
use opencv::{core::VecN, prelude::*, videoio};

// transforms the input file to h264
#[derive(Parser, Debug)]
struct Args {
    /// an mp4 file generated by opencv
    input: String,
    /// name of the file to save
    output: String,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    let mut cam = videoio::VideoCapture::from_file(&args.input, videoio::CAP_ANY)?;
    let opened = videoio::VideoCapture::is_opened(&cam)?;
    if !opened {
        panic!("Unable to open video file!");
    }

    // https://docs.opencv.org/3.4/d4/d15/group__videoio__flags__base.html
    let frame_width = cam.get(3)? as i32;
    let frame_height = cam.get(4)? as i32;
    let fps = cam.get(5)?;

    let output_file = OpenOptions::new()
        .read(false)
        .write(true)
        .create(true)
        .truncate(true)
        .open(args.output)?;
    let mut writer = BufWriter::new(output_file);
    let mut encoder = x264::Encoder::builder()
        .fps(fps as _, 1)
        .build(x264::Colorspace::RGB, frame_width as _, frame_height as _)
        .expect("failed to make builder");
    let mut idx = 0;
    // let m: [[f32; 3]; 3] = [
    //     [0.183, 0.614, 0.062],
    //     [-0.101, -0.339, 0.439],
    //     [0.439, -0.399, -0.040],
    // ];
    // let p = m.as_ptr() as *mut std::ffi::c_void;
    // let m = unsafe {
    //     Mat::new_rows_cols_with_data(3, 3, opencv::core::CV_32F, p, opencv::core::Mat_AUTO_STEP)
    // }?;

    loop {
        let mut frame = Mat::default();
        if !cam.read(&mut frame)? {
            println!("read entire video file");
            break;
        }
        // let mut xformed = Mat::default();
        // opencv::core::transform(&frame, &mut xformed, &m)?;
        let sz = frame.size()?;
        println!("sz: {sz:?}");
        if sz.width > 0 {
            let p = frame.data_mut();
            let cols = frame.cols();
            let rows = frame.rows();
            let len = cols * rows;
            let s = std::ptr::slice_from_raw_parts(p, len as _);

            println!("rows: {rows}, cols: {cols}, len: {len}");

            let width = cols;
            let height= rows;

            let plane = x264::Plane {
                // todo: try to get stride from opencv
                stride: width,
                data: unsafe { &*s },
            };
            let planes = vec![plane];


            // Check that the number of planes matches pc.
            assert!(planes.len() == 1);
            // Check that the width and the height are multiples of wm and hm.
            for (i, plane) in planes.iter().enumerate() {
                println!("plane: stride: {}, len: {}", plane.stride, plane.data.len());
                // Check that the plane's stride is at least depth * wq * ws[i].
                assert!(1 * width * 3 <= plane.stride);
                // Check that there are at least hq * hs[i] rows in the plane.
                assert!(height * 1 <= plane.data.len() as i32 / plane.stride);
            }

            let img = x264::Image::rgb(sz.width, sz.height, unsafe{&*s});
            let (data, _) = encoder
                .encode(fps as i64 * idx as i64, img)
                .expect("failed to encode frame");
            idx += 1;
            writer.write(data.entirety())?;
        }
    }
    writer.flush()?;
    Ok(())
}
