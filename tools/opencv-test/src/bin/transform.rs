use std::{
    fs::OpenOptions,
    io::{BufWriter, Write},
};

use clap::Parser;
use opencv::{prelude::*, videoio};

// transforms the input file to h264
#[derive(Parser, Debug)]
struct Args {
    /// an mp4 file generated by opencv
    input: String,
    /// name of the file to save
    output: String,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    let mut cam = videoio::VideoCapture::from_file(&args.input, videoio::CAP_ANY)?;
    let opened = videoio::VideoCapture::is_opened(&cam)?;
    if !opened {
        panic!("Unable to open video file!");
    }

    // https://docs.opencv.org/3.4/d4/d15/group__videoio__flags__base.html
    let frame_width = cam.get(3)? as _;
    let frame_height = cam.get(4)? as _;
    let fps = cam.get(5)? as _;

    let output_file = OpenOptions::new()
        .read(false)
        .write(true)
        .create(true)
        .truncate(true)
        .open(args.output)?;
    let mut writer = BufWriter::new(output_file);

    let config =
        openh264::encoder::EncoderConfig::new(frame_width, frame_height).max_frame_rate(fps); //.rate_control_mode(openh264::encoder::RateControlMode::Timestamp);

    let mut encoder = openh264::encoder::Encoder::with_config(config)?;

    // https://web.archive.org/web/20180423091842/http://www.equasys.de/colorconversion.html
    // be sure to pick the full-scale conversion

    let get_y = |rgb: (f32, f32, f32)| {
        (0.2578125 * rgb.0 + 0.50390625 * rgb.1 + 0.09765625 * rgb.2 + 16.0) as u8
    };

    let get_u = |rgb: (f32, f32, f32)| {
        (-0.1484375 * rgb.0 + -0.2890625 * rgb.1 + 0.4375 * rgb.2 + 128.0) as u8
    };

    let get_v = |rgb: (f32, f32, f32)| {
        (0.4375 * rgb.0 + -0.3671875 * rgb.1 + -0.0703125 * rgb.2 + 128.0) as u8
    };

    // for y
    let y_rc_2_idx = |row: usize, col: usize| (row * frame_width as usize * 2) + col;

    loop {
        let mut frame = Mat::default();
        if !cam.read(&mut frame)? {
            println!("read entire video file");
            break;
        }

        let sz = frame.size()?;
        let width = sz.width as usize;
        let height = sz.height as usize;
        if width > 0 {
            let p = frame.data_mut();
            let len = width * height * 3;
            let s = std::ptr::slice_from_raw_parts(p, len as _);
            let s: &[u8] = unsafe { &*s };

            // width x height for u and v. and 4 times witdh x height for y
            let yuv_len = (width * height) * 6;
            let mut yuv: Vec<u8> = Vec::new();
            yuv.resize(yuv_len, 0);
            let u_base = (width * height) * 4;
            let v_base = u_base + (width * height);
            let mut uv_idx = 0;
            for row in 0..height {
                for col in 0..width {
                    let base_pos = (row + col * width) * 3;
                    let b = s[base_pos];
                    let g = s[base_pos + 1];
                    let r = s[base_pos + 2];

                    let rgb = (r as _, g as _, b as _);
                    let (y, u, v) = (get_y(rgb), get_u(rgb), get_v(rgb));

                    // each byte in the u/v plane corresponds to a 4x4 square on the y plane
                    let y_row = row * 2;
                    let y_col = col * 2;

                    let idx = y_rc_2_idx(y_row, y_col);
                    yuv[idx] = y;
                    yuv[idx + 1] = y;
                    let idx = y_rc_2_idx(y_row + 1, y_col);
                    yuv[idx] = y;
                    yuv[idx + 1] = y;

                    yuv[u_base + uv_idx] = u;
                    yuv[v_base + uv_idx] = v;
                    uv_idx += 1;
                }
            }

            let yuv_buf = opencv_test::utils::YUVBuf {
                yuv,
                width: width * 2,
                height: height * 2,
            };

            let encoded_stream = encoder.encode(&yuv_buf)?;
            encoded_stream.write(&mut writer)?;
        }
    }
    writer.flush()?;
    Ok(())
}
