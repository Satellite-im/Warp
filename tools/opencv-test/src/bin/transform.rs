use std::{fs::OpenOptions, io::{BufWriter, Write}};

use clap::Parser;
use opencv::{prelude::*, videoio, core::{CV_32F, Mat_AUTO_STEP, DecompTypes}};
use openh264::{encoder::{Encoder, EncoderConfig}, formats::YUVSource};

// transforms the input file to h264
#[derive(Parser, Debug)]
struct Args {
    /// an mp4 file generated by opencv
    input: String,
    /// name of the file to save
    output: String,
}

 fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    let mut cam = videoio::VideoCapture::from_file(&args.input, videoio::CAP_ANY)?;
    let opened = videoio::VideoCapture::is_opened(&cam)?;
    if !opened {
        panic!("Unable to open video file!");
    }

    // https://docs.opencv.org/3.4/d4/d15/group__videoio__flags__base.html
    let frame_width = cam.get(3)? as i32;
    let frame_height = cam.get(4)? as i32;
    let fps = cam.get(5)?;

    let output_file = OpenOptions::new().read(false).write(true).create(true).truncate(true).open(args.output)?;
    let mut writer = BufWriter::new(output_file);
    let encoder_config = EncoderConfig::new(frame_width as u32, frame_height as u32);
    let h264_encoder = Encoder::with_config(encoder_config)?;
    loop {
        let mut frame = Mat::default();
        if !cam.read(&mut frame)? {
            println!("read entire video file");
            break;
        }
        // supposedly [M][RGB]=[YUV]
        let mut m: [[f32; 3]; 3] = [[0.299, 0.587, 0.114], [-0.14713, -0.28886, 0.436], [0.615, -0.51499, -0.10001]];
        let p = m.as_ptr() as *mut std::ffi::c_void;
        let M = unsafe {Mat::new_rows_cols_with_data(3,3,CV_32F, p, Mat_AUTO_STEP)}?; // may need to .inv() this
        // shows how to invert a matrix
        // let M = M.inv(DecompTypes::DECOMP_SVD as i32)?;
        let mut xformed = Mat::default();
        opencv::core::transform(&frame, &mut xformed, &M)?;
        let wrapper = YuvWrapper::new(frame_width , frame_height , Box::new(xformed));
        if frame.size()?.width > 0 {
            let encoded = h264_encoder.encode(&wrapper)?;
            writer.write(&encoded.to_vec());
           // writer.write(&xformed)?;
        }
    }
    writer.flush()?;
    Ok(())
}

// each pixel is a 3-tuple
struct YuvWrapper {
    width: i32,
    height: i32,
    data: Box<dyn opencv::core::ToOutputArray>
}

impl YuvWrapper {
    fn new(width: i32, height: i32, data: Box<dyn opencv::core::ToOutputArray>)  -> Self {
        Self {
            width,
            height,
            data
        }
    }
}

impl YUVSource for YuvWrapper {
    fn width(&self) -> i32 {
        self.width
    }

    fn height(&self) -> i32 {
        self.height
    }

    fn y(&self) -> &[u8] {
        todo!()
    }

    fn u(&self) -> &[u8] {
        todo!()
    }

    fn v(&self) -> &[u8] {
        todo!()
    }

    fn y_stride(&self) -> i32 {
        todo!()
    }

    fn u_stride(&self) -> i32 {
        todo!()
    }

    fn v_stride(&self) -> i32 {
        todo!()
    }
    
}